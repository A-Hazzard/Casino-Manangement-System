import jsPDF from "jspdf";
import "jspdf-autotable";
import * as XLSX from "xlsx";
import { format } from "date-fns";
import type { 
  ExportDataStructure, 
  MachineExportData, 
  LocationExportData 
} from "@/lib/types/reports";

declare module "jspdf" {
  interface jsPDF {
    autoTable: (options: {
      startY?: number;
      head?: string[][];
      body?: (string | number)[][];
      theme?: string;
      headStyles?: Record<string, unknown>;
      margin?: Record<string, number>;
      styles?: Record<string, unknown>;
    }) => jsPDF;
  }
}

export type ExportFormat = "pdf" | "csv" | "excel";

export interface ExportData {
  title: string;
  subtitle?: string;
  headers: string[];
  data: (string | number)[][];
  summary?: {
    label: string;
    value: string | number;
  }[];
  metadata?: {
    generatedBy: string;
    generatedAt: string;
    dateRange?: string;
  };
}

// Base64 encoded EOS logo (placeholder - you'll need to replace with actual logo)
const EOS_LOGO_BASE64 = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==`;

export class ExportUtils {
  static async exportToPDF(data: ExportData): Promise<void> {
    const doc = new jsPDF();

    // Add logo
    try {
      doc.addImage(EOS_LOGO_BASE64, "PNG", 15, 15, 30, 15);
    } catch (error) {
      console.warn("Could not add logo to PDF:", error);
    }

    // Header
    doc.setFontSize(20);
    doc.setTextColor(44, 62, 80);
    doc.text(data.title, 15, 45);

    if (data.subtitle) {
      doc.setFontSize(12);
      doc.setTextColor(127, 140, 141);
      doc.text(data.subtitle, 15, 55);
    }

    // Metadata
    let yPosition = data.subtitle ? 70 : 60;
    if (data.metadata) {
      doc.setFontSize(10);
      doc.setTextColor(127, 140, 141);
      doc.text(`Generated by: ${data.metadata.generatedBy}`, 15, yPosition);
      doc.text(`Generated at: ${data.metadata.generatedAt}`, 15, yPosition + 5);
      if (data.metadata.dateRange) {
        doc.text(`Date Range: ${data.metadata.dateRange}`, 15, yPosition + 10);
      }
      yPosition += 20;
    }

    // Summary section
    if (data.summary && data.summary.length > 0) {
      doc.setFontSize(14);
      doc.setTextColor(44, 62, 80);
      doc.text("Summary", 15, yPosition);
      yPosition += 10;

      const summaryData = data.summary.map((item) => [item.label, item.value]);

      doc.autoTable({
        startY: yPosition,
        head: [["Metric", "Value"]],
        body: summaryData,
        theme: "grid",
        headStyles: { fillColor: [52, 152, 219] },
        margin: { left: 15, right: 15 },
      });

      yPosition = (doc as jsPDF & { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 15;
    }

    // Main data table
    if (data.data.length > 0) {
      doc.setFontSize(14);
      doc.setTextColor(44, 62, 80);
      doc.text("Detailed Data", 15, yPosition);
      yPosition += 10;

      doc.autoTable({
        startY: yPosition,
        head: [data.headers],
        body: data.data,
        theme: "striped",
        headStyles: { fillColor: [52, 152, 219] },
        margin: { left: 15, right: 15 },
        styles: { fontSize: 8 },
      });
    }

    // Footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(127, 140, 141);
      doc.text(
        `Page ${i} of ${pageCount} | Evolution1 CMS Reports`,
        15,
        doc.internal.pageSize.height - 10
      );
      doc.text(
        format(new Date(), "yyyy-MM-dd HH:mm:ss"),
        doc.internal.pageSize.width - 60,
        doc.internal.pageSize.height - 10
      );
    }

    // Save the PDF
    const fileName = `${data.title.replace(/\s+/g, "_").toLowerCase()}_${format(
      new Date(),
      "yyyy-MM-dd_HH-mm-ss"
    )}.pdf`;
    doc.save(fileName);
  }

  static exportToCSV(data: ExportData): void {
    let csvContent = "";

    // Add title and metadata
    csvContent += `"${data.title}"\n`;
    if (data.subtitle) {
      csvContent += `"${data.subtitle}"\n`;
    }
    csvContent += "\n";

    if (data.metadata) {
      csvContent += `"Generated by","${data.metadata.generatedBy}"\n`;
      csvContent += `"Generated at","${data.metadata.generatedAt}"\n`;
      if (data.metadata.dateRange) {
        csvContent += `"Date Range","${data.metadata.dateRange}"\n`;
      }
      csvContent += "\n";
    }

    // Add summary
    if (data.summary && data.summary.length > 0) {
      csvContent += '"Summary"\n';
      csvContent += '"Metric","Value"\n';
      data.summary.forEach((item) => {
        csvContent += `"${item.label}","${item.value}"\n`;
      });
      csvContent += "\n";
    }

    // Add main data
    if (data.data.length > 0) {
      csvContent += '"Detailed Data"\n';
      csvContent +=
        data.headers.map((header) => `"${header}"`).join(",") + "\n";
      data.data.forEach((row) => {
        csvContent += row.map((cell) => `"${cell}"`).join(",") + "\n";
      });
    }

    // Download CSV
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    const fileName = `${data.title.replace(/\s+/g, "_").toLowerCase()}_${format(
      new Date(),
      "yyyy-MM-dd_HH-mm-ss"
    )}.csv`;
    link.setAttribute("download", fileName);
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  static exportToExcel(data: ExportData): void {
    const workbook = XLSX.utils.book_new();

    // Create worksheet data
    const wsData: (string | number)[][] = [];

    // Add title and metadata
    wsData.push([data.title]);
    if (data.subtitle) {
      wsData.push([data.subtitle]);
    }
    wsData.push([]);

    if (data.metadata) {
      wsData.push(["Generated by", data.metadata.generatedBy]);
      wsData.push(["Generated at", data.metadata.generatedAt]);
      if (data.metadata.dateRange) {
        wsData.push(["Date Range", data.metadata.dateRange]);
      }
      wsData.push([]);
    }

    // Add summary
    if (data.summary && data.summary.length > 0) {
      wsData.push(["Summary"]);
      wsData.push(["Metric", "Value"]);
      data.summary.forEach((item) => {
        wsData.push([item.label, item.value]);
      });
      wsData.push([]);
    }

    // Add main data
    if (data.data.length > 0) {
      wsData.push(["Detailed Data"]);
      wsData.push(data.headers);
      data.data.forEach((row) => {
        wsData.push(row);
      });
    }

    // Create worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(wsData);

    // Set column widths
    const colWidths = data.headers.map(() => ({ wch: 15 }));
    worksheet["!cols"] = colWidths;

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, "Report");

    // Save the file
    const fileName = `${data.title.replace(/\s+/g, "_").toLowerCase()}_${format(
      new Date(),
      "yyyy-MM-dd_HH-mm-ss"
    )}.xlsx`;
    XLSX.writeFile(workbook, fileName);
  }

  static async exportData(
    data: ExportData,
    format: ExportFormat
  ): Promise<void> {
    try {
      switch (format) {
        case "pdf":
          await this.exportToPDF(data);
          break;
        case "csv":
          this.exportToCSV(data);
          break;
        case "excel":
          this.exportToExcel(data);
          break;
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }
    } catch (error) {
      console.error("Export failed:", error);
      throw error;
    }
  }
}

// Helper function to format machine data for export
export function formatMachineDataForExport(machines: MachineExportData[]): ExportDataStructure {
  return {
    title: "Machine Performance Report",
    subtitle: "Comprehensive analysis of gaming machine performance",
    headers: [
      "Machine ID",
      "Game Title",
      "Manufacturer",
      "Location",
      "Handle",
      "Win",
      "Hold %",
      "Games Played",
      "Status",
    ],
    data: machines.map((machine) => [
      machine.id,
      machine.gameTitle,
      machine.manufacturer,
      machine.locationName,
      machine.totalHandle.toLocaleString(),
      machine.totalWin.toLocaleString(),
      `${machine.actualHold.toFixed(1)}%`,
      machine.gamesPlayed.toLocaleString(),
      machine.isActive ? "Active" : "Inactive",
    ]),
    summary: [
      { label: "Total Machines", value: machines.length },
      {
        label: "Active Machines",
        value: machines.filter((m) => m.isActive).length,
      },
      {
        label: "Total Handle",
        value: `$${machines
          .reduce((sum, m) => sum + m.totalHandle, 0)
          .toLocaleString()}`,
      },
      {
        label: "Total Win",
        value: `$${machines
          .reduce((sum, m) => sum + m.totalWin, 0)
          .toLocaleString()}`,
      },
      {
        label: "Average Hold %",
        value: `${(
          machines.reduce((sum, m) => sum + m.actualHold, 0) / machines.length
        ).toFixed(1)}%`,
      },
    ],
    metadata: {
      generatedBy: "Evolution1 CMS",
      generatedAt: format(new Date(), "yyyy-MM-dd HH:mm:ss"),
      dateRange: "All Time",
    },
  };
}

// Helper function to format location data for export
export function formatLocationDataForExport(locations: LocationExportData[]): ExportDataStructure {
  return {
    title: "Location Performance Report",
    subtitle: "Performance analysis across all casino locations",
    headers: [
      "Location ID",
      "Location Name",
      "Region",
      "Handle",
      "Win",
      "Hold %",
      "Games Played",
      "Status",
    ],
    data: locations.map((location) => [
      location.id,
      location.name,
      location.region,
      location.totalHandle.toLocaleString(),
      location.totalWin.toLocaleString(),
      `${location.actualHold.toFixed(1)}%`,
      location.gamesPlayed.toLocaleString(),
      location.isActive ? "Active" : "Inactive",
    ]),
    summary: [
      { label: "Total Locations", value: locations.length },
      {
        label: "Active Locations",
        value: locations.filter((l) => l.isActive).length,
      },
      {
        label: "Total Handle",
        value: `$${locations
          .reduce((sum, l) => sum + l.totalHandle, 0)
          .toLocaleString()}`,
      },
      {
        label: "Total Win",
        value: `$${locations
          .reduce((sum, l) => sum + l.totalWin, 0)
          .toLocaleString()}`,
      },
      {
        label: "Average Hold %",
        value: `${(
          locations.reduce((sum, l) => sum + l.actualHold, 0) / locations.length
        ).toFixed(1)}%`,
      },
    ],
    metadata: {
      generatedBy: "Evolution1 CMS",
      generatedAt: format(new Date(), "yyyy-MM-dd HH:mm:ss"),
      dateRange: "All Time",
    },
  };
}
