/**
 * Export Utilities
 *
 * Comprehensive utility functions for exporting data to various formats (PDF, Excel).
 *
 * Features:
 * - PDF export with styling and logos
 * - Excel export functionality
 * - Machine and location data exports
 * - Legacy export support
 * - Type definitions for export data structures
 */

import { format } from 'date-fns';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';
// Remove the problematic import since ExportDataStructure doesn't exist
import { toast } from 'sonner';

// jsPDF autotable typings are declared in lib/types/jspdf-autotable.d.ts

import type {
  ExportData,
  ExportFormat,
  LegacyExportData,
} from '@shared/types/export';

// ============================================================================
// Type Definitions
// ============================================================================
// Re-export shared types for convenience
export type { ExportData, ExportFormat, LegacyExportData };

/**
 * Machine export data structure
 */
export type MachineExportData = {
  serialNumber?: string;
  origSerialNumber?: string;
  machineId?: string;
  game: string;
  location: string;
  moneyIn: number;
  moneyOut: number;
  gross: number;
  jackpot: number;
  gamesPlayed: number;
  lastActivity: Date;
};

export type LocationExportData = {
  locationName: string;
  totalMachines: number;
  onlineMachines: number;
  moneyIn: number;
  moneyOut: number;
  gross: number;
  performance: string;
};

// Extended LegacyExportData type with missing properties
export type ExtendedLegacyExportData = LegacyExportData & {
  title: string;
  subtitle?: string;
  metadata?: {
    generatedBy: string;
    generatedAt: string;
    dateRange?: string;
    tab?: string;
    selectedLocations?: string | number;
  };
  summary?: Array<{ label: string; value: string }>;
  headers: string[];
  data: (string | number | undefined)[][];
};

// Specific types for export data arrays
export type OverviewItem = {
  locationName?: string;
  moneyIn?: number;
  moneyOut?: number;
  gross?: number;
  day?: string;
};

export type SasEvaluationItem = {
  locationName?: string;
  totalMachines?: number;
  onlineMachines?: number;
  performance?: string;
  moneyIn?: number;
};

export type RevenueAnalysisItem = {
  locationName?: string;
  machineId?: string;
  game?: string;
  manufacturer?: string;
  handle?: number;
  winLoss?: number;
  jackpot?: number;
  gamesPlayed?: number;
  avgWagerPerGame?: number;
  actualHold?: number;
};

export type MachineItem = {
  machineId?: string;
  machineName?: string;
  gameTitle?: string;
  locationName?: string;
  manufacturer?: string;
  machineType?: string;
  netWin?: number;
  drop?: number;
  totalCancelledCredits?: number;
  jackpot?: number;
  gamesPlayed?: number;
  actualHold?: number;
  isOnline?: boolean;
  isSasEnabled?: boolean;
};

// Extended ExportData type with proper types
export type ExtendedExportData = {
  overview: OverviewItem[];
  sasEvaluation: SasEvaluationItem[];
  revenueAnalysis: RevenueAnalysisItem[];
  machines: MachineItem[];
  metadata: {
    generatedAt: Date;
    timePeriod: string;
    selectedLocations: string[];
    selectedLicencee?: string;
  };
};

export type ExportDataStructure = {
  headers: string[];
  data: (string | number | undefined)[][];
  metadata: {
    title: string;
    generatedAt: Date;
    filters: {
      dateRange: string;
      generatedBy: string;
    };
  };
};

import axios from 'axios';

// Function to load and convert the EOS logo to base64
const getEOSLogoBase64 = async (): Promise<string> => {
  try {
    const response = await axios.get('/EOS_Logo.png', {
      responseType: 'blob',
    });
    const blob = response.data;
    return new Promise(resolve => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result as string);
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.warn('Could not load EOS logo:', error);
    return '';
  }
};

export class ExportUtils {
  static async exportToPDF(data: ExtendedLegacyExportData): Promise<void> {
    const doc = new jsPDF();

    // Add logo
    try {
      const logoBase64 = await getEOSLogoBase64();
      if (logoBase64) {
        doc.addImage(logoBase64, 'PNG', 15, 15, 30, 15);
      }
    } catch (error) {
      console.warn('Could not add logo to PDF:', error);
    }

    // Header
    doc.setFontSize(20);
    doc.setTextColor(44, 62, 80);
    doc.text(data.title, 15, 45);

    if (data.subtitle) {
      doc.setFontSize(12);
      doc.setTextColor(127, 140, 141);
      doc.text(data.subtitle, 15, 55);
    }

    // Metadata
    let yPosition = data.subtitle ? 70 : 60;
    if (data.metadata) {
      doc.setFontSize(10);
      doc.setTextColor(127, 140, 141);
      doc.text(`Generated by: ${data.metadata.generatedBy}`, 15, yPosition);
      doc.text(`Generated at: ${data.metadata.generatedAt}`, 15, yPosition + 5);
      if (data.metadata.dateRange) {
        doc.text(`Date Range: ${data.metadata.dateRange}`, 15, yPosition + 10);
      }
      yPosition += 20;
    }

    // Summary section
    if (data.summary && data.summary.length > 0) {
      doc.setFontSize(14);
      doc.setTextColor(44, 62, 80);
      doc.text('Summary', 15, yPosition);
      yPosition += 10;

      const summaryData = data.summary.map(
        (item: { label: string; value: string }) => [item.label, item.value]
      );

      autoTable(doc, {
        startY: yPosition,
        head: [['Metric', 'Value']],
        body: summaryData,
        theme: 'grid',
        headStyles: { fillColor: [52, 152, 219] },
        margin: { left: 15, right: 15 },
      });

      yPosition =
        (doc as jsPDF & { lastAutoTable: { finalY: number } }).lastAutoTable
          .finalY + 15;
    }

    // Main data table
    if (data.data.length > 0) {
      doc.setFontSize(14);
      doc.setTextColor(44, 62, 80);
      doc.text('Detailed Data', 15, yPosition);
      yPosition += 10;

      // Check if last row is a totals row (starts with "TOTAL")
      const lastRow = data.data[data.data.length - 1];
      const isTotalsRow = lastRow && lastRow[0] === 'TOTAL';
      const bodyData = isTotalsRow ? data.data.slice(0, -1) : data.data;
      const totalsRow = isTotalsRow ? lastRow : null;

      autoTable(doc, {
        startY: yPosition,
        head: [data.headers],
        body: bodyData as (string | number)[][],
        theme: 'striped',
        headStyles: { fillColor: [52, 152, 219] },
        margin: { left: 15, right: 15 },
        styles: { fontSize: 8 },
      });

      // Add totals row with bold styling if it exists
      if (totalsRow) {
        const finalY =
          (doc as jsPDF & { lastAutoTable?: { finalY?: number } }).lastAutoTable
            ?.finalY || yPosition;
        autoTable(doc, {
          startY: finalY + 5,
          body: [totalsRow.map(cell => cell ?? '') as (string | number)[]],
          theme: 'plain',
          headStyles: { fillColor: [52, 152, 219] },
          margin: { left: 15, right: 15 },
          styles: {
            fontSize: 8,
            fontStyle: 'bold' as const,
            fillColor: [240, 240, 240],
            textColor: [0, 0, 0],
          },
          columnStyles: data.headers.reduce(
            (acc: Record<string, { fontStyle: 'bold' }>, _, index) => {
              acc[index.toString()] = { fontStyle: 'bold' };
              return acc;
            },
            {}
          ),
        });
      }
    }

    // Footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(127, 140, 141);
      doc.text(
        `Page ${i} of ${pageCount} | Evolution1 CMS Reports`,
        15,
        doc.internal.pageSize.height - 10
      );
      doc.text(
        format(new Date(), 'yyyy-MM-dd HH:mm:ss'),
        doc.internal.pageSize.width - 60,
        doc.internal.pageSize.height - 10
      );
    }

    // Save the PDF
    const fileName = `${data.title.replace(/\s+/g, '_').toLowerCase()}_${format(
      new Date(),
      'yyyy-MM-dd_HH-mm-ss'
    )}.pdf`;
    doc.save(fileName);
  }

  static exportToCSV(data: ExtendedLegacyExportData): void {
    let csvContent = '';

    // Add title and metadata
    csvContent += `"${data.title}"\n`;
    if (data.subtitle) {
      csvContent += `"${data.subtitle}"\n`;
    }
    csvContent += '\n';

    if (data.metadata) {
      csvContent += `"Generated by","${data.metadata.generatedBy}"\n`;
      csvContent += `"Generated at","${data.metadata.generatedAt}"\n`;
      if (data.metadata.dateRange) {
        csvContent += `"Date Range","${data.metadata.dateRange}"\n`;
      }
      csvContent += '\n';
    }

    // Add summary
    if (data.summary && data.summary.length > 0) {
      csvContent += '"Summary"\n';
      csvContent += '"Metric","Value"\n';
      data.summary.forEach((item: { label: string; value: string }) => {
        csvContent += `"${item.label}","${item.value}"\n`;
      });
      csvContent += '\n';
    }

    // Add main data
    if (data.data.length > 0) {
      csvContent += '"Detailed Data"\n';
      csvContent += data.headers.map(header => `"${header}"`).join(',') + '\n';
      data.data.forEach((row: (string | number | undefined)[]) => {
        csvContent +=
          row
            .map((cell: string | number | undefined) => `"${cell ?? ''}"`)
            .join(',') + '\n';
      });
    }

    // Download CSV
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    const fileName = `${data.title.replace(/\s+/g, '_').toLowerCase()}_${format(
      new Date(),
      'yyyy-MM-dd_HH-mm-ss'
    )}.csv`;
    link.setAttribute('download', fileName);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  static exportToExcel(data: ExtendedLegacyExportData): void {
    const workbook = XLSX.utils.book_new();

    // Create worksheet data
    const wsData: (string | number)[][] = [];

    // Add title and metadata
    wsData.push([data.title]);
    if (data.subtitle) {
      wsData.push([data.subtitle]);
    }
    wsData.push([]);

    if (data.metadata) {
      wsData.push(['Generated by', data.metadata.generatedBy]);
      wsData.push(['Generated at', data.metadata.generatedAt]);
      if (data.metadata.dateRange) {
        wsData.push(['Date Range', data.metadata.dateRange]);
      }
      wsData.push([]);
    }

    // Add summary
    if (data.summary && data.summary.length > 0) {
      wsData.push(['Summary']);
      wsData.push(['Metric', 'Value']);
      data.summary.forEach((item: { label: string; value: string }) => {
        wsData.push([item.label, item.value]);
      });
      wsData.push([]);
    }

    // Add main data
    if (data.data.length > 0) {
      wsData.push(['Detailed Data']);
      wsData.push(data.headers);
      data.data.forEach((row: (string | number | undefined)[]) => {
        wsData.push(row.map(cell => cell ?? ''));
      });
    }

    // Create worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(wsData);

    // Set column widths - make them wider for better number display
    const colWidths = data.headers.map(header => {
      // Make numeric columns wider
      if (
        header.includes('Meters') ||
        header.includes('Money') ||
        header.includes('Games') ||
        header.includes('Bill') ||
        header.includes('Voucher') ||
        header.includes('Jackpot')
      ) {
        return { wch: 20 }; // Wider for large numbers
      }
      return { wch: 15 }; // Standard width for other columns
    });
    worksheet['!cols'] = colWidths;

    // Apply number formatting to numeric columns
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
    for (let col = 0; col < data.headers.length; col++) {
      const header = data.headers[col];
      if (
        header.includes('Meters') ||
        header.includes('Money') ||
        header.includes('Games') ||
        header.includes('Bill') ||
        header.includes('Voucher') ||
        header.includes('Jackpot')
      ) {
        // Apply number format to all cells in this column (skip header row)
        for (let row = range.s.r + 1; row <= range.e.r; row++) {
          const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
          if (worksheet[cellAddress]) {
            // Set cell type to number and format
            worksheet[cellAddress].t = 'n';
            worksheet[cellAddress].z = '#,##0'; // Number format with thousands separator
          }
        }
      }
    }

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Report');

    // Save the file
    const fileName = `${data.title.replace(/\s+/g, '_').toLowerCase()}_${format(
      new Date(),
      'yyyy-MM-dd_HH-mm-ss'
    )}.xlsx`;
    XLSX.writeFile(workbook, fileName);
  }

  static async exportData(
    data: ExtendedLegacyExportData,
    format: ExportFormat
  ): Promise<void> {
    try {
      switch (format) {
        case 'pdf':
          await this.exportToPDF(data);
          break;
        case 'csv':
          this.exportToCSV(data);
          break;
        case 'excel':
          this.exportToExcel(data);
          break;
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }
    } catch (error) {
      console.error('Export failed:', error);
      throw error;
    }
  }
}

// Helper function to format machine data for export
export function formatMachineDataForExport(
  machines: MachineExportData[]
): ExportDataStructure {
  return {
    headers: [
      'Serial Number',
      'Game',
      'Location',
      'Money In',
      'Money Out',
      'Gross',
      'Jackpot',
      'Games Played',
      'Last Activity',
    ],
    data: machines.map(machine => [
      (typeof (machine as { serialNumber?: string }).serialNumber ===
        'string' &&
        (machine as { serialNumber?: string }).serialNumber?.trim()) ||
        (typeof (machine as { origSerialNumber?: string }).origSerialNumber ===
          'string' &&
          (
            machine as { origSerialNumber?: string }
          ).origSerialNumber?.trim()) ||
        (machine as { machineId?: string }).machineId,
      machine.game,
      machine.location,
      machine.moneyIn.toLocaleString(),
      machine.moneyOut.toLocaleString(),
      machine.gross.toLocaleString(),
      machine.jackpot.toLocaleString(),
      machine.gamesPlayed.toLocaleString(),
      machine.lastActivity.toLocaleDateString(),
    ]),
    metadata: {
      title: 'Machine Performance Report',
      generatedAt: new Date(),
      filters: {
        dateRange: 'All Time',
        generatedBy: 'Evolution1 CMS',
      },
    },
  };
}

// Helper function to format location data for export
export function formatLocationDataForExport(
  locations: LocationExportData[]
): ExportDataStructure {
  return {
    headers: [
      'Location Name',
      'Total Machines',
      'Online Machines',
      'Money In',
      'Money Out',
      'Gross',
      'Performance',
    ],
    data: locations.map(location => [
      location.locationName,
      location.totalMachines.toString(),
      location.onlineMachines.toString(),
      location.moneyIn.toLocaleString(),
      location.moneyOut.toLocaleString(),
      location.gross.toLocaleString(),
      location.performance,
    ]),
    metadata: {
      title: 'Location Performance Report',
      generatedAt: new Date(),
      filters: {
        dateRange: 'All Time',
        generatedBy: 'Evolution1 CMS',
      },
    },
  };
}

// Fetch overview data
const fetchOverviewData = async (
  timePeriod: string,
  licencee?: string,
  locationIds?: string[]
) => {
  try {
    const params = new URLSearchParams({
      timePeriod,
      ...(licencee && { licencee }),
      ...(locationIds &&
        locationIds.length > 0 && { locationIds: locationIds.join(',') }),
    });

    const response = await axios.get(`/api/analytics/dashboard?${params}`);
    return response.data.data || [];
  } catch (error) {
    console.error('Error fetching overview data:', error);
    return [];
  }
};

// Fetch SAS evaluation data
const fetchSASEvaluationData = async (
  timePeriod: string,
  licencee?: string,
  locationIds?: string[]
) => {
  try {
    const params = new URLSearchParams({
      timePeriod,
      ...(licencee && { licencee }),
      ...(locationIds &&
        locationIds.length > 0 && { locationIds: locationIds.join(',') }),
    });

    const response = await axios.get(`/api/analytics/locations?${params}`);
    return response.data.data || [];
  } catch (error) {
    console.error('Error fetching SAS evaluation data:', error);
    return [];
  }
};

// Fetch revenue analysis data
const fetchRevenueAnalysisData = async (
  timePeriod: string,
  licencee?: string,
  locationIds?: string[]
) => {
  try {
    const params = new URLSearchParams({
      timePeriod,
      ...(licencee && { licencee }),
      ...(locationIds &&
        locationIds.length > 0 && { locationIds: locationIds.join(',') }),
    });

    const response = await axios.get(
      `/api/metrics/top-machines?${params}&limit=100`
    );
    return response.data.data || [];
  } catch (error) {
    console.error('Error fetching revenue analysis data:', error);
    return [];
  }
};

// Fetch machines data
const fetchMachinesData = async (
  timePeriod: string,
  licencee?: string,
  locationIds?: string[]
) => {
  try {
    const params = new URLSearchParams({
      timePeriod,
      limit: '100', // Get more machines for export
      ...(licencee && licencee !== 'all' && { licencee }),
      ...(locationIds &&
        locationIds.length > 0 && { locationIds: locationIds.join(',') }),
    });

    const response = await axios.get(`/api/reports/machines?${params}`);
    return response.data.data || [];
  } catch (error) {
    console.error('Error fetching machines data:', error);
    return [];
  }
};

// Convert data to Excel format
const convertToExcelFormat = (data: ExtendedExportData) => {
  const workbook = {
    sheets: [
      {
        name: 'Overview',
        data: data.overview.map((item: OverviewItem) => ({
          Location: item.locationName || 'Unknown',
          'Total Revenue': item.moneyIn || 0,
          'Total Payout': item.moneyOut || 0,
          'Gross Profit': item.gross || 0,
          Date: item.day || 'Unknown',
        })),
      },
      {
        name: 'SAS Evaluation',
        data: data.sasEvaluation.map((item: SasEvaluationItem) => ({
          Location: item.locationName || 'Unknown',
          'Total Machines': item.totalMachines || 0,
          'Online Machines': item.onlineMachines || 0,
          Performance: item.performance || 'Unknown',
          Revenue: item.moneyIn || 0,
        })),
      },
      {
        name: 'Revenue Analysis',
        data: data.revenueAnalysis.map((item: RevenueAnalysisItem) => ({
          Location: item.locationName || 'Unknown',
          'Machine ID': item.machineId || 'Unknown',
          Game: item.game || 'Unknown',
          Manufacturer: item.manufacturer || 'Not Specified',
          Handle: item.handle || 0,
          'Win/Loss': item.winLoss || 0,
          Jackpot: item.jackpot || 0,
          'Games Played': item.gamesPlayed || 0,
          'Avg Wager': item.avgWagerPerGame || 0,
          'Actual Hold %': item.actualHold || 0,
        })),
      },
      {
        name: 'Machines',
        data: data.machines.map((item: MachineItem) => ({
          'Machine ID': item.machineId || 'Unknown',
          'Machine Name': item.machineName || 'Unknown',
          'Game Title': item.gameTitle || 'Unknown',
          Location: item.locationName || 'Unknown',
          Manufacturer: item.manufacturer || 'Unknown',
          Type: item.machineType || 'Unknown',
          'Net Win': item.netWin || 0,
          Drop: item.drop || 0,
          'Cancelled Credits': item.totalCancelledCredits || 0,
          Jackpot: item.jackpot || 0,
          'Games Played': item.gamesPlayed || 0,
          'Hold %': item.actualHold || 0,
          Status: item.isOnline ? 'Online' : 'Offline',
          'SAS Enabled': item.isSasEnabled ? 'Yes' : 'No',
        })),
      },
      {
        name: 'Metadata',
        data: [
          { 'Generated At': data.metadata.generatedAt.toLocaleString() },
          { 'Time Period': data.metadata.timePeriod },
          {
            'Selected Locations':
              data.metadata.selectedLocations.join(', ') || 'All',
          },
          { Licencee: data.metadata.selectedLicencee || 'All' },
        ],
      },
    ],
  };

  return workbook;
};

// Download Excel file
const downloadExcel = (
  workbook: {
    sheets: Array<{ name: string; data: Record<string, unknown>[] }>;
  },
  filename: string
) => {
  // For now, we'll create a CSV-like format that can be opened in Excel
  // In a production environment, you'd use a library like xlsx or exceljs

  let csvContent = '';

  workbook.sheets.forEach(
    (sheet: { name: string; data: Record<string, unknown>[] }) => {
      csvContent += `\n=== ${sheet.name} ===\n`;

      if (sheet.data.length > 0) {
        // Headers
        const headers = Object.keys(sheet.data[0]);
        csvContent += headers.join(',') + '\n';

        // Data rows
        sheet.data.forEach((row: Record<string, unknown>) => {
          const values = headers.map(header => {
            const value = row[header];
            // Escape commas and quotes
            if (
              typeof value === 'string' &&
              (value.includes(',') || value.includes('"'))
            ) {
              return `"${value.replace(/"/g, '""')}"`;
            }
            return value;
          });
          csvContent += values.join(',') + '\n';
        });
      }

      csvContent += '\n';
    }
  );

  // Create and download file
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

// Main export function for all reports
export const exportAllReports = async (
  timePeriod: string,
  licencee?: string,
  locationIds?: string[]
) => {
  try {
    // Fetch all data including machines
    const [overviewData, sasData, revenueData, machinesData] =
      await Promise.all([
        fetchOverviewData(timePeriod, licencee, locationIds),
        fetchSASEvaluationData(timePeriod, licencee, locationIds),
        fetchRevenueAnalysisData(timePeriod, licencee, locationIds),
        fetchMachinesData(timePeriod, licencee, locationIds),
      ]);

    // Prepare export data
    const exportData: ExtendedExportData = {
      overview: overviewData,
      sasEvaluation: sasData,
      revenueAnalysis: revenueData,
      machines: machinesData,
      metadata: {
        generatedAt: new Date(),
        timePeriod,
        selectedLocations: locationIds || [],
        selectedLicencee: licencee,
      },
    };

    // Convert to Excel format
    const workbook = convertToExcelFormat(exportData);

    // Generate filename
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `casino-reports-${timePeriod}-${timestamp}.csv`;

    // Download file
    downloadExcel(workbook, filename);

    toast.success('Export completed successfully!', {
      duration: 3000,
    });
  } catch (error) {
    console.error('Export error:', error);
    toast.error('Failed to export reports. Please try again.', {
      duration: 3000,
    });
  }
};

// Legacy export function for individual reports (maintains backward compatibility)
export const exportData = async (data: ExtendedLegacyExportData) => {
  try {
    // For now, we'll create a CSV-like format that can be opened in Excel
    let csvContent = '';

    // Title and subtitle
    csvContent += `${data.title}\n`;
    if (data.subtitle) {
      csvContent += `${data.subtitle}\n`;
    }
    csvContent += '\n';

    // Headers
    csvContent += data.headers.join(',') + '\n';

    // Data rows
    data.data.forEach((row: (string | number | undefined)[]) => {
      const values = row.map((value: string | number | undefined) => {
        // Handle undefined values
        if (value === undefined) return '';
        // Escape commas and quotes
        if (
          typeof value === 'string' &&
          (value.includes(',') || value.includes('"'))
        ) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value;
      });
      csvContent += values.join(',') + '\n';
    });

    // Summary
    if (data.summary && data.summary.length > 0) {
      csvContent += '\nSummary:\n';
      data.summary.forEach((item: { label: string; value: string }) => {
        csvContent += `${item.label}: ${item.value}\n`;
      });
    }

    // Metadata
    if (data.metadata) {
      csvContent += '\nMetadata:\n';
      csvContent += `Generated by: ${data.metadata.generatedBy}\n`;
      csvContent += `Generated at: ${data.metadata.generatedAt}\n`;
      if (data.metadata.dateRange) {
        csvContent += `Date range: ${data.metadata.dateRange}\n`;
      }
    }

    // Create and download file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute(
      'download',
      `${data.title.toLowerCase().replace(/\s+/g, '-')}-${
        new Date().toISOString().split('T')[0]
      }.csv`
    );
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    toast.success('Export completed successfully!', {
      duration: 3000,
    });
  } catch (error) {
    console.error('Export error:', error);
    toast.error('Failed to export data. Please try again.', {
      duration: 3000,
    });
  }
};
