import jsPDF from "jspdf";
import "jspdf-autotable";
import * as XLSX from "xlsx";
import { format } from "date-fns";
import type {
  ExportDataStructure,
  MachineExportData,
  LocationExportData,
} from "@/lib/types/reports";
import { toast } from "sonner";

declare module "jspdf" {
  interface jsPDF {
    autoTable: (options: {
      startY?: number;
      head?: string[][];
      body?: (string | number)[][];
      theme?: string;
      headStyles?: Record<string, unknown>;
      margin?: Record<string, number>;
      styles?: Record<string, unknown>;
    }) => jsPDF;
  }
}

export type ExportFormat = "pdf" | "csv" | "excel";

export type ExportData = {
  overview: any[];
  sasEvaluation: any[];
  revenueAnalysis: any[];
  machines: any[];
  metadata: {
    generatedAt: Date;
    timePeriod: string;
    selectedLocations: string[];
    selectedLicencee?: string;
  };
};

// Legacy export data type for individual reports
export type LegacyExportData = {
  title: string;
  subtitle?: string;
  headers: string[];
  data: (string | number)[][];
  summary?: {
    label: string;
    value: string | number;
  }[];
  metadata?: {
    generatedBy: string;
    generatedAt: string;
    dateRange?: string;
  };
};

// Function to load and convert the EOS logo to base64
const getEOSLogoBase64 = async (): Promise<string> => {
  try {
    const response = await fetch('/EOS_Logo.png');
    const blob = await response.blob();
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result as string);
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.warn("Could not load EOS logo:", error);
    return '';
  }
};

export class ExportUtils {
  static async exportToPDF(data: LegacyExportData): Promise<void> {
    const doc = new jsPDF();

    // Add logo
    try {
      const logoBase64 = await getEOSLogoBase64();
      if (logoBase64) {
        doc.addImage(logoBase64, "PNG", 15, 15, 30, 15);
      }
    } catch (error) {
      console.warn("Could not add logo to PDF:", error);
    }

    // Header
    doc.setFontSize(20);
    doc.setTextColor(44, 62, 80);
    doc.text(data.title, 15, 45);

    if (data.subtitle) {
      doc.setFontSize(12);
      doc.setTextColor(127, 140, 141);
      doc.text(data.subtitle, 15, 55);
    }

    // Metadata
    let yPosition = data.subtitle ? 70 : 60;
    if (data.metadata) {
      doc.setFontSize(10);
      doc.setTextColor(127, 140, 141);
      doc.text(`Generated by: ${data.metadata.generatedBy}`, 15, yPosition);
      doc.text(`Generated at: ${data.metadata.generatedAt}`, 15, yPosition + 5);
      if (data.metadata.dateRange) {
        doc.text(`Date Range: ${data.metadata.dateRange}`, 15, yPosition + 10);
      }
      yPosition += 20;
    }

    // Summary section
    if (data.summary && data.summary.length > 0) {
      doc.setFontSize(14);
      doc.setTextColor(44, 62, 80);
      doc.text("Summary", 15, yPosition);
      yPosition += 10;

      const summaryData = data.summary.map((item) => [item.label, item.value]);

      doc.autoTable({
        startY: yPosition,
        head: [["Metric", "Value"]],
        body: summaryData,
        theme: "grid",
        headStyles: { fillColor: [52, 152, 219] },
        margin: { left: 15, right: 15 },
      });

      yPosition =
        (doc as jsPDF & { lastAutoTable: { finalY: number } }).lastAutoTable
          .finalY + 15;
    }

    // Main data table
    if (data.data.length > 0) {
      doc.setFontSize(14);
      doc.setTextColor(44, 62, 80);
      doc.text("Detailed Data", 15, yPosition);
      yPosition += 10;

      doc.autoTable({
        startY: yPosition,
        head: [data.headers],
        body: data.data,
        theme: "striped",
        headStyles: { fillColor: [52, 152, 219] },
        margin: { left: 15, right: 15 },
        styles: { fontSize: 8 },
      });
    }

    // Footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(127, 140, 141);
      doc.text(
        `Page ${i} of ${pageCount} | Evolution1 CMS Reports`,
        15,
        doc.internal.pageSize.height - 10
      );
      doc.text(
        format(new Date(), "yyyy-MM-dd HH:mm:ss"),
        doc.internal.pageSize.width - 60,
        doc.internal.pageSize.height - 10
      );
    }

    // Save the PDF
    const fileName = `${data.title.replace(/\s+/g, "_").toLowerCase()}_${format(
      new Date(),
      "yyyy-MM-dd_HH-mm-ss"
    )}.pdf`;
    doc.save(fileName);
  }

  static exportToCSV(data: LegacyExportData): void {
    let csvContent = "";

    // Add title and metadata
    csvContent += `"${data.title}"\n`;
    if (data.subtitle) {
      csvContent += `"${data.subtitle}"\n`;
    }
    csvContent += "\n";

    if (data.metadata) {
      csvContent += `"Generated by","${data.metadata.generatedBy}"\n`;
      csvContent += `"Generated at","${data.metadata.generatedAt}"\n`;
      if (data.metadata.dateRange) {
        csvContent += `"Date Range","${data.metadata.dateRange}"\n`;
      }
      csvContent += "\n";
    }

    // Add summary
    if (data.summary && data.summary.length > 0) {
      csvContent += '"Summary"\n';
      csvContent += '"Metric","Value"\n';
      data.summary.forEach((item) => {
        csvContent += `"${item.label}","${item.value}"\n`;
      });
      csvContent += "\n";
    }

    // Add main data
    if (data.data.length > 0) {
      csvContent += '"Detailed Data"\n';
      csvContent +=
        data.headers.map((header) => `"${header}"`).join(",") + "\n";
      data.data.forEach((row) => {
        csvContent += row.map((cell) => `"${cell}"`).join(",") + "\n";
      });
    }

    // Download CSV
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    const fileName = `${data.title.replace(/\s+/g, "_").toLowerCase()}_${format(
      new Date(),
      "yyyy-MM-dd_HH-mm-ss"
    )}.csv`;
    link.setAttribute("download", fileName);
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  static exportToExcel(data: LegacyExportData): void {
    const workbook = XLSX.utils.book_new();

    // Create worksheet data
    const wsData: (string | number)[][] = [];

    // Add title and metadata
    wsData.push([data.title]);
    if (data.subtitle) {
      wsData.push([data.subtitle]);
    }
    wsData.push([]);

    if (data.metadata) {
      wsData.push(["Generated by", data.metadata.generatedBy]);
      wsData.push(["Generated at", data.metadata.generatedAt]);
      if (data.metadata.dateRange) {
        wsData.push(["Date Range", data.metadata.dateRange]);
      }
      wsData.push([]);
    }

    // Add summary
    if (data.summary && data.summary.length > 0) {
      wsData.push(["Summary"]);
      wsData.push(["Metric", "Value"]);
      data.summary.forEach((item) => {
        wsData.push([item.label, item.value]);
      });
      wsData.push([]);
    }

    // Add main data
    if (data.data.length > 0) {
      wsData.push(["Detailed Data"]);
      wsData.push(data.headers);
      data.data.forEach((row) => {
        wsData.push(row);
      });
    }

    // Create worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(wsData);

    // Set column widths - make them wider for better number display
    const colWidths = data.headers.map((header) => {
      // Make numeric columns wider
      if (header.includes("Meters") || header.includes("Money") || header.includes("Games") || 
          header.includes("Bill") || header.includes("Voucher") || header.includes("Jackpot")) {
        return { wch: 20 }; // Wider for large numbers
      }
      return { wch: 15 }; // Standard width for other columns
    });
    worksheet["!cols"] = colWidths;

    // Apply number formatting to numeric columns
    const range = XLSX.utils.decode_range(worksheet["!ref"] || "A1");
    for (let col = 0; col < data.headers.length; col++) {
      const header = data.headers[col];
      if (header.includes("Meters") || header.includes("Money") || header.includes("Games") || 
          header.includes("Bill") || header.includes("Voucher") || header.includes("Jackpot")) {
        // Apply number format to all cells in this column (skip header row)
        for (let row = range.s.r + 1; row <= range.e.r; row++) {
          const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
          if (worksheet[cellAddress]) {
            // Set cell type to number and format
            worksheet[cellAddress].t = 'n';
            worksheet[cellAddress].z = '#,##0'; // Number format with thousands separator
          }
        }
      }
    }

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, "Report");

    // Save the file
    const fileName = `${data.title.replace(/\s+/g, "_").toLowerCase()}_${format(
      new Date(),
      "yyyy-MM-dd_HH-mm-ss"
    )}.xlsx`;
    XLSX.writeFile(workbook, fileName);
  }

  static async exportData(
    data: LegacyExportData,
    format: ExportFormat
  ): Promise<void> {
    try {
      switch (format) {
        case "pdf":
          await this.exportToPDF(data);
          break;
        case "csv":
          this.exportToCSV(data);
          break;
        case "excel":
          this.exportToExcel(data);
          break;
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }
    } catch (error) {
      console.error("Export failed:", error);
      throw error;
    }
  }
}

// Helper function to format machine data for export
export function formatMachineDataForExport(
  machines: MachineExportData[]
): ExportDataStructure {
  return {
    title: "Machine Performance Report",
    subtitle: "Comprehensive analysis of gaming machine performance",
    headers: [
      "Machine ID",
      "Game Title",
      "Manufacturer",
      "Location",
      "Handle",
      "Win",
      "Hold %",
      "Games Played",
      "Status",
    ],
    data: machines.map((machine) => [
      machine.id,
      machine.gameTitle,
      machine.manufacturer,
      machine.locationName,
      machine.totalHandle.toLocaleString(),
      machine.totalWin.toLocaleString(),
      `${machine.actualHold.toFixed(1)}%`,
      machine.gamesPlayed.toLocaleString(),
      machine.isActive ? "Active" : "Inactive",
    ]),
    summary: [
      { label: "Total Machines", value: machines.length },
      {
        label: "Active Machines",
        value: machines.filter((m) => m.isActive).length,
      },
      {
        label: "Total Handle",
        value: `$${machines
          .reduce((sum, m) => sum + m.totalHandle, 0)
          .toLocaleString()}`,
      },
      {
        label: "Total Win",
        value: `$${machines
          .reduce((sum, m) => sum + m.totalWin, 0)
          .toLocaleString()}`,
      },
      {
        label: "Average Hold %",
        value: `${(
          machines.reduce((sum, m) => sum + m.actualHold, 0) / machines.length
        ).toFixed(1)}%`,
      },
    ],
    metadata: {
      generatedBy: "Evolution1 CMS",
      generatedAt: format(new Date(), "yyyy-MM-dd HH:mm:ss"),
      dateRange: "All Time",
    },
  };
}

// Helper function to format location data for export
export function formatLocationDataForExport(
  locations: LocationExportData[]
): ExportDataStructure {
  return {
    title: "Location Performance Report",
    subtitle: "Performance analysis across all casino locations",
    headers: [
      "Location ID",
      "Location Name",
      "Region",
      "Handle",
      "Win",
      "Hold %",
      "Games Played",
      "Status",
    ],
    data: locations.map((location) => [
      location.id,
      location.name,
      location.region,
      location.totalHandle.toLocaleString(),
      location.totalWin.toLocaleString(),
      `${location.actualHold.toFixed(1)}%`,
      location.gamesPlayed.toLocaleString(),
      location.isActive ? "Active" : "Inactive",
    ]),
    summary: [
      { label: "Total Locations", value: locations.length },
      {
        label: "Active Locations",
        value: locations.filter((l) => l.isActive).length,
      },
      {
        label: "Total Handle",
        value: `$${locations
          .reduce((sum, l) => sum + l.totalHandle, 0)
          .toLocaleString()}`,
      },
      {
        label: "Total Win",
        value: `$${locations
          .reduce((sum, l) => sum + l.totalWin, 0)
          .toLocaleString()}`,
      },
      {
        label: "Average Hold %",
        value: `${(
          locations.reduce((sum, l) => sum + l.actualHold, 0) / locations.length
        ).toFixed(1)}%`,
      },
    ],
    metadata: {
      generatedBy: "Evolution1 CMS",
      generatedAt: format(new Date(), "yyyy-MM-dd HH:mm:ss"),
      dateRange: "All Time",
    },
  };
}

// Fetch overview data
const fetchOverviewData = async (timePeriod: string, licencee?: string, locationIds?: string[]) => {
  try {
    const params = new URLSearchParams({
      timePeriod,
      ...(licencee && { licencee }),
      ...(locationIds && locationIds.length > 0 && { locationIds: locationIds.join(",") })
    });

    const response = await fetch(`/api/analytics/dashboard?${params}`);
    if (!response.ok) throw new Error('Failed to fetch overview data');
    
    const data = await response.json();
    return data.data || [];
  } catch (error) {
    console.error('Error fetching overview data:', error);
    return [];
  }
};

// Fetch SAS evaluation data
const fetchSASEvaluationData = async (timePeriod: string, licencee?: string, locationIds?: string[]) => {
  try {
    const params = new URLSearchParams({
      timePeriod,
      ...(licencee && { licencee }),
      ...(locationIds && locationIds.length > 0 && { locationIds: locationIds.join(",") })
    });

    const response = await fetch(`/api/analytics/locations?${params}`);
    if (!response.ok) throw new Error('Failed to fetch SAS evaluation data');
    
    const data = await response.json();
    return data.data || [];
  } catch (error) {
    console.error('Error fetching SAS evaluation data:', error);
    return [];
  }
};

// Fetch revenue analysis data
const fetchRevenueAnalysisData = async (timePeriod: string, licencee?: string, locationIds?: string[]) => {
  try {
    const params = new URLSearchParams({
      timePeriod,
      ...(licencee && { licencee }),
      ...(locationIds && locationIds.length > 0 && { locationIds: locationIds.join(",") })
    });

    const response = await fetch(`/api/metrics/top-machines?${params}&limit=100`);
    if (!response.ok) throw new Error('Failed to fetch revenue analysis data');
    
    const data = await response.json();
    return data.data || [];
  } catch (error) {
    console.error('Error fetching revenue analysis data:', error);
    return [];
  }
};

// Fetch machines data
const fetchMachinesData = async (timePeriod: string, licencee?: string, locationIds?: string[]) => {
  try {
    const params = new URLSearchParams({
      timePeriod,
      limit: "100", // Get more machines for export
      ...(licencee && licencee !== "all" && { licencee }),
      ...(locationIds && locationIds.length > 0 && { locationIds: locationIds.join(",") })
    });

    const response = await fetch(`/api/reports/machines?${params}`);
    if (!response.ok) throw new Error('Failed to fetch machines data');
    
    const data = await response.json();
    return data.data || [];
  } catch (error) {
    console.error('Error fetching machines data:', error);
    return [];
  }
};

// Convert data to Excel format
const convertToExcelFormat = (data: ExportData) => {
  const workbook = {
    sheets: [
      {
        name: 'Overview',
        data: data.overview.map(item => ({
          'Location': item.locationName || 'Unknown',
          'Total Revenue': item.moneyIn || 0,
          'Total Payout': item.moneyOut || 0,
          'Gross Profit': item.gross || 0,
          'Date': item.day || 'Unknown'
        }))
      },
      {
        name: 'SAS Evaluation',
        data: data.sasEvaluation.map(item => ({
          'Location': item.locationName || 'Unknown',
          'Total Machines': item.totalMachines || 0,
          'Online Machines': item.onlineMachines || 0,
          'Performance': item.performance || 'Unknown',
          'Revenue': item.moneyIn || 0
        }))
      },
      {
        name: 'Revenue Analysis',
        data: data.revenueAnalysis.map(item => ({
          'Location': item.locationName || 'Unknown',
          'Machine ID': item.machineId || 'Unknown',
          'Game': item.game || 'Unknown',
          'Manufacturer': item.manufacturer || 'Not Specified',
          'Handle': item.handle || 0,
          'Win/Loss': item.winLoss || 0,
          'Jackpot': item.jackpot || 0,
          'Games Played': item.gamesPlayed || 0,
          'Avg Wager': item.avgWagerPerGame || 0,
          'Actual Hold %': item.actualHold || 0
        }))
      },
      {
        name: 'Machines',
        data: data.machines.map(item => ({
          'Machine ID': item.machineId || 'Unknown',
          'Machine Name': item.machineName || 'Unknown',
          'Game Title': item.gameTitle || 'Unknown',
          'Location': item.locationName || 'Unknown',
          'Manufacturer': item.manufacturer || 'Unknown',
          'Type': item.machineType || 'Unknown',
          'Net Win': item.netWin || 0,
          'Drop': item.drop || 0,
          'Cancelled Credits': item.totalCancelledCredits || 0,
          'Jackpot': item.jackpot || 0,
          'Games Played': item.gamesPlayed || 0,
          'Hold %': item.actualHold || 0,
          'Status': item.isOnline ? 'Online' : 'Offline',
          'SAS Enabled': item.isSasEnabled ? 'Yes' : 'No'
        }))
      },
      {
        name: 'Metadata',
        data: [
          { 'Generated At': data.metadata.generatedAt.toLocaleString() },
          { 'Time Period': data.metadata.timePeriod },
          { 'Selected Locations': data.metadata.selectedLocations.join(', ') || 'All' },
          { 'Licencee': data.metadata.selectedLicencee || 'All' }
        ]
      }
    ]
  };

  return workbook;
};

// Download Excel file
const downloadExcel = (workbook: any, filename: string) => {
  // For now, we'll create a CSV-like format that can be opened in Excel
  // In a production environment, you'd use a library like xlsx or exceljs
  
  let csvContent = '';
  
  workbook.sheets.forEach((sheet: any, sheetIndex: number) => {
    csvContent += `\n=== ${sheet.name} ===\n`;
    
    if (sheet.data.length > 0) {
      // Headers
      const headers = Object.keys(sheet.data[0]);
      csvContent += headers.join(',') + '\n';
      
      // Data rows
      sheet.data.forEach((row: any) => {
        const values = headers.map(header => {
          const value = row[header];
          // Escape commas and quotes
          if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value;
        });
        csvContent += values.join(',') + '\n';
      });
    }
    
    csvContent += '\n';
  });
  
  // Create and download file
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

// Main export function for all reports
export const exportAllReports = async (
  timePeriod: string,
  licencee?: string,
  locationIds?: string[]
) => {
  try {
    toast.loading('Preparing export...');
    
    // Fetch all data including machines
    const [overviewData, sasData, revenueData, machinesData] = await Promise.all([
      fetchOverviewData(timePeriod, licencee, locationIds),
      fetchSASEvaluationData(timePeriod, licencee, locationIds),
      fetchRevenueAnalysisData(timePeriod, licencee, locationIds),
      fetchMachinesData(timePeriod, licencee, locationIds)
    ]);
    
    // Prepare export data
    const exportData: ExportData = {
      overview: overviewData,
      sasEvaluation: sasData,
      revenueAnalysis: revenueData,
      machines: machinesData,
      metadata: {
        generatedAt: new Date(),
        timePeriod,
        selectedLocations: locationIds || [],
        selectedLicencee: licencee
      }
    };
    
    // Convert to Excel format
    const workbook = convertToExcelFormat(exportData);
    
    // Generate filename
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `casino-reports-${timePeriod}-${timestamp}.csv`;
    
    // Download file
    downloadExcel(workbook, filename);
    
    toast.dismiss();
    toast.success('Export completed successfully!');
    
  } catch (error) {
    console.error('Export error:', error);
    toast.dismiss();
    toast.error('Failed to export reports. Please try again.');
  }
};

// Legacy export function for individual reports (maintains backward compatibility)
export const exportData = async (data: LegacyExportData, format: string = "csv") => {
  try {
    toast.loading('Preparing export...');
    
    // For now, we'll create a CSV-like format that can be opened in Excel
    let csvContent = '';
    
    // Title and subtitle
    csvContent += `${data.title}\n`;
    if (data.subtitle) {
      csvContent += `${data.subtitle}\n`;
    }
    csvContent += '\n';
    
    // Headers
    csvContent += data.headers.join(',') + '\n';
    
    // Data rows
    data.data.forEach(row => {
      const values = row.map(value => {
        // Escape commas and quotes
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value;
      });
      csvContent += values.join(',') + '\n';
    });
    
    // Summary
    if (data.summary && data.summary.length > 0) {
      csvContent += '\nSummary:\n';
      data.summary.forEach(item => {
        csvContent += `${item.label}: ${item.value}\n`;
      });
    }
    
    // Metadata
    if (data.metadata) {
      csvContent += '\nMetadata:\n';
      csvContent += `Generated by: ${data.metadata.generatedBy}\n`;
      csvContent += `Generated at: ${data.metadata.generatedAt}\n`;
      if (data.metadata.dateRange) {
        csvContent += `Date range: ${data.metadata.dateRange}\n`;
      }
    }
    
    // Create and download file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `${data.title.toLowerCase().replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    toast.dismiss();
    toast.success('Export completed successfully!');
    
  } catch (error) {
    console.error('Export error:', error);
    toast.dismiss();
    toast.error('Failed to export data. Please try again.');
  }
};
