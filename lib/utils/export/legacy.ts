/**
 * Export Utilities
 *
 * Comprehensive utility functions for exporting data to various formats (PDF, Excel).
 *
 * Features:
 * - PDF export with styling and logos
 * - Excel export functionality
 * - Machine and location data exports
 * - Legacy export support
 * - Type definitions for export data structures
 */

import { format } from 'date-fns';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';

// jsPDF autotable typings are declared in lib/types/jspdf-autotable.d.ts

type LegacyExportData = {
  title: string;
  subtitle?: string;
  headers: string[];
  data: (string | number | undefined)[][];
  summary?: Array<{ label: string; value: string }>;
  metadata?: {
    generatedBy: string;
    generatedAt: string;
    dateRange?: string;
  };
};

type ExportFormat = 'pdf' | 'csv' | 'excel';

//Extended LegacyExportData type with missing properties
export type ExtendedLegacyExportData = LegacyExportData & {
  title: string;
  subtitle?: string;
  metadata?: {
    generatedBy: string;
    generatedAt: string;
    dateRange?: string;
    tab?: string;
    selectedLocations?: string | number;
  };
  summary?: Array<{ label: string; value: string }>;
  headers: string[];
  data: (string | number | undefined)[][];
};

import axios from 'axios';

// Function to load and convert the EOS logo to base64
const getEOSLogoBase64 = async (): Promise<string> => {
  try {
    const response = await axios.get('/EOS_Logo.png', {
      responseType: 'blob',
    });
    const blob = response.data;
    return new Promise(resolve => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result as string);
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.warn('Could not load EOS logo:', error);
    return '';
  }
};

export class ExportUtils {
  static async exportToPDF(data: ExtendedLegacyExportData): Promise<void> {
    const doc = new jsPDF();

    // Add logo
    try {
      const logoBase64 = await getEOSLogoBase64();
      if (logoBase64) {
        doc.addImage(logoBase64, 'PNG', 15, 15, 30, 15);
      }
    } catch (error) {
      console.warn('Could not add logo to PDF:', error);
    }

    // Header
    doc.setFontSize(20);
    doc.setTextColor(44, 62, 80);
    doc.text(data.title, 15, 45);

    if (data.subtitle) {
      doc.setFontSize(12);
      doc.setTextColor(127, 140, 141);
      doc.text(data.subtitle, 15, 55);
    }

    // Metadata
    let yPosition = data.subtitle ? 70 : 60;
    if (data.metadata) {
      doc.setFontSize(10);
      doc.setTextColor(127, 140, 141);
      doc.text(`Generated by: ${data.metadata.generatedBy}`, 15, yPosition);
      doc.text(`Generated at: ${data.metadata.generatedAt}`, 15, yPosition + 5);
      if (data.metadata.dateRange) {
        doc.text(`Date Range: ${data.metadata.dateRange}`, 15, yPosition + 10);
      }
      yPosition += 20;
    }

    // Summary section
    if (data.summary && data.summary.length > 0) {
      doc.setFontSize(14);
      doc.setTextColor(44, 62, 80);
      doc.text('Summary', 15, yPosition);
      yPosition += 10;

      const summaryData = data.summary.map(
        (item: { label: string; value: string }) => [item.label, item.value]
      );

      autoTable(doc, {
        startY: yPosition,
        head: [['Metric', 'Value']],
        body: summaryData,
        theme: 'grid',
        headStyles: { fillColor: [52, 152, 219] },
        margin: { left: 15, right: 15 },
      });

      yPosition =
        (doc as jsPDF & { lastAutoTable: { finalY: number } }).lastAutoTable
          .finalY + 15;
    }

    // Main data table
    if (data.data.length > 0) {
      doc.setFontSize(14);
      doc.setTextColor(44, 62, 80);
      doc.text('Detailed Data', 15, yPosition);
      yPosition += 10;

      // Check if last row is a totals row (starts with "TOTAL")
      const lastRow = data.data[data.data.length - 1];
      const isTotalsRow = lastRow && lastRow[0] === 'TOTAL';
      const bodyData = isTotalsRow ? data.data.slice(0, -1) : data.data;
      const totalsRow = isTotalsRow ? lastRow : null;

      autoTable(doc, {
        startY: yPosition,
        head: [data.headers],
        body: bodyData as (string | number)[][],
        theme: 'striped',
        headStyles: { fillColor: [52, 152, 219] },
        margin: { left: 15, right: 15 },
        styles: { fontSize: 8 },
      });

      // Add totals row with bold styling if it exists
      if (totalsRow) {
        const finalY =
          (doc as jsPDF & { lastAutoTable?: { finalY?: number } }).lastAutoTable
            ?.finalY || yPosition;
        autoTable(doc, {
          startY: finalY + 5,
          body: [totalsRow.map(cell => cell ?? '') as (string | number)[]],
          theme: 'plain',
          headStyles: { fillColor: [52, 152, 219] },
          margin: { left: 15, right: 15 },
          styles: {
            fontSize: 8,
            fontStyle: 'bold' as const,
            fillColor: [240, 240, 240],
            textColor: [0, 0, 0],
          },
          columnStyles: data.headers.reduce(
            (acc: Record<string, { fontStyle: 'bold' }>, _, index) => {
              acc[index.toString()] = { fontStyle: 'bold' };
              return acc;
            },
            {}
          ),
        });
      }
    }

    // Footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(127, 140, 141);
      doc.text(
        `Page ${i} of ${pageCount} | Evolution1 CMS Reports`,
        15,
        doc.internal.pageSize.height - 10
      );
      doc.text(
        format(new Date(), 'yyyy-MM-dd HH:mm:ss'),
        doc.internal.pageSize.width - 60,
        doc.internal.pageSize.height - 10
      );
    }

    // Save the PDF
    const fileName = `${data.title.replace(/\s+/g, '_').toLowerCase()}_${format(
      new Date(),
      'yyyy-MM-dd_HH-mm-ss'
    )}.pdf`;
    doc.save(fileName);
  }

  static exportToCSV(data: ExtendedLegacyExportData): void {
    let csvContent = '';

    // Add title and metadata
    csvContent += `"${data.title}"\n`;
    if (data.subtitle) {
      csvContent += `"${data.subtitle}"\n`;
    }
    csvContent += '\n';

    if (data.metadata) {
      csvContent += `"Generated by","${data.metadata.generatedBy}"\n`;
      csvContent += `"Generated at","${data.metadata.generatedAt}"\n`;
      if (data.metadata.dateRange) {
        csvContent += `"Date Range","${data.metadata.dateRange}"\n`;
      }
      csvContent += '\n';
    }

    // Add summary
    if (data.summary && data.summary.length > 0) {
      csvContent += '"Summary"\n';
      csvContent += '"Metric","Value"\n';
      data.summary.forEach((item: { label: string; value: string }) => {
        csvContent += `"${item.label}","${item.value}"\n`;
      });
      csvContent += '\n';
    }

    // Add main data
    if (data.data.length > 0) {
      csvContent += '"Detailed Data"\n';
      csvContent += data.headers.map(header => `"${header}"`).join(',') + '\n';
      data.data.forEach((row: (string | number | undefined)[]) => {
        csvContent +=
          row
            .map((cell: string | number | undefined) => `"${cell ?? ''}"`)
            .join(',') + '\n';
      });
    }

    // Download CSV
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    const fileName = `${data.title.replace(/\s+/g, '_').toLowerCase()}_${format(
      new Date(),
      'yyyy-MM-dd_HH-mm-ss'
    )}.csv`;
    link.setAttribute('download', fileName);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  static exportToExcel(data: ExtendedLegacyExportData): void {
    const workbook = XLSX.utils.book_new();

    // Create worksheet data
    const wsData: (string | number)[][] = [];

    // Add title and metadata
    wsData.push([data.title]);
    if (data.subtitle) {
      wsData.push([data.subtitle]);
    }
    wsData.push([]);

    if (data.metadata) {
      wsData.push(['Generated by', data.metadata.generatedBy]);
      wsData.push(['Generated at', data.metadata.generatedAt]);
      if (data.metadata.dateRange) {
        wsData.push(['Date Range', data.metadata.dateRange]);
      }
      wsData.push([]);
    }

    // Add summary
    if (data.summary && data.summary.length > 0) {
      wsData.push(['Summary']);
      wsData.push(['Metric', 'Value']);
      data.summary.forEach((item: { label: string; value: string }) => {
        wsData.push([item.label, item.value]);
      });
      wsData.push([]);
    }

    // Add main data
    if (data.data.length > 0) {
      wsData.push(['Detailed Data']);
      wsData.push(data.headers);
      data.data.forEach((row: (string | number | undefined)[]) => {
        wsData.push(row.map(cell => cell ?? ''));
      });
    }

    // Create worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(wsData);

    // Set column widths - make them wider for better number display
    const colWidths = data.headers.map(header => {
      // Make numeric columns wider
      if (
        header.includes('Meters') ||
        header.includes('Money') ||
        header.includes('Games') ||
        header.includes('Bill') ||
        header.includes('Voucher') ||
        header.includes('Jackpot')
      ) {
        return { wch: 20 }; // Wider for large numbers
      }
      return { wch: 15 }; // Standard width for other columns
    });
    worksheet['!cols'] = colWidths;

    // Apply number formatting to numeric columns
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
    for (let col = 0; col < data.headers.length; col++) {
      const header = data.headers[col];
      if (
        header.includes('Meters') ||
        header.includes('Money') ||
        header.includes('Games') ||
        header.includes('Bill') ||
        header.includes('Voucher') ||
        header.includes('Jackpot')
      ) {
        // Apply number format to all cells in this column (skip header row)
        for (let row = range.s.r + 1; row <= range.e.r; row++) {
          const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
          if (worksheet[cellAddress]) {
            // Set cell type to number and format
            worksheet[cellAddress].t = 'n';
            worksheet[cellAddress].z = '#,##0'; // Number format with thousands separator
          }
        }
      }
    }

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Report');

    // Save the file
    const fileName = `${data.title.replace(/\s+/g, '_').toLowerCase()}_${format(
      new Date(),
      'yyyy-MM-dd_HH-mm-ss'
    )}.xlsx`;
    XLSX.writeFile(workbook, fileName);
  }

  static async exportData(
    data: ExtendedLegacyExportData,
    format: ExportFormat
  ): Promise<void> {
    try {
      switch (format) {
        case 'pdf':
          await this.exportToPDF(data);
          break;
        case 'csv':
          this.exportToCSV(data);
          break;
        case 'excel':
          this.exportToExcel(data);
          break;
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }
    } catch (error) {
      console.error('Export failed:', error);
      throw error;
    }
  }
}

